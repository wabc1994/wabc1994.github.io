
---
layout: post
title:  "go协程机制"
date:   2019-6-01 9:50:9
categories: 网络
comments: true
tags:   
    - 网络
   
---

* content
{:toc}


# 前言
涉及到高性能服务器以及多线程编程过程中，如何提高服务器的并发量和响应处理事件，同时维护好代码的可读性是个很重要的问题

从最开始的Unix五种I/0模型，单进程，多进程，单进程多线程，以及单进程单线程，这些并发模型，到现在的go 协程机制都是

# 协程与异步
同步阻塞模式：
- 缺点：一个线程一个服务，产生大量的开销
- 优点：中间不需要插入其他的逻辑， 编程逻辑简单

# 异步方式
基于事件回调机制来解决异步执行的缺点

>如果A,B,C三个应用程序，后面两个要依赖前面一个的执行结果，我们可以设置注册两个回调函数，即当满足条件了主动回调，比如现在很多网络库就是这样工作的libenvent库，基于事件机制的回调模式

**什么叫异步编程**
>A在启动B任务时就不管了，继续执行自己的任务，当B完成时，由操作系统主动通知A，告知B已经完成。A可以在适宜的时候取出B的执行结果。在这种模式下，A完全不会因为B的执行而影响自己。


说白了就是某个条件是否满足，
	- 操作系统通知，或者系统调用epoll
	- 自己轮询
	- 或者设计一个第三方的调度器


```
epoll_ctl  add  read event;
```

做其他事情去了，

1. epoll_wait返回了socket可读
2. 读socket数据
3. 写数据到socketzhong1

**异步开发的难点**
> 异步开发中较难的一点在于异步事件的正确处理，处理不当就可能被资源


# 协程工作的本质
1. yield() 和resume()

比如python当中的生成器,微信libco当中的co_create,co_yield, 实现异步化的改造


# go的解决之道
协程得以让我们以同步的方式去编写代码，但是能够收到的

go语言中是Go自己的调度器来通知routine等待的IO事件是否完成，而其它非协程语言则是OS来通知。


这样就比较方便能用同步的逻辑写异步代码

# 协程调度

线程是由操作系统来调度，那么既然协程是用户级别的线程，那么自然协程的调度是由用户程序来进行管理，这也是Go的调度器 Schelur类的简单作用情况。

这里面也要注意应用层面的线程是如何映射到操作系统级别的线程机制 

 1. N:M  多对多，
 2. N:1   
 3. 1:1 


**不同的映射关系会带来不同的调度效果，以及涉及到的上下文切换**


# 协程内存管理
c++ 当中有虚拟内存分布，提供给用户上层的
1. Java 有自己的运行时数据区以及内存模型，GC垃圾收起自动管理内存
2. go又是怎么做好内存管理，比如stack，

# 参考链接
[聊聊如何用协程优雅地做异步开发](https://zhuanlan.zhihu.com/p/37962034)

